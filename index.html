<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Просмотр XML-отчётов: list.xml → inspection-YYYY-M.xml → ZIP/XML с проверками</title>
<style>
  :root{
    --bg:#ffffff;
    --fg:#0f172a;
    --muted:#64748b;
    --card:#f8fafc;
    --line:#e2e8f0;
    --accent:#0ea5e9;
    --accent-soft:#e0f2fe;
    --ok:#059669;
    --warn:#d97706;
    --err:#dc2626;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
  }
  h1{font-size:18px;margin:16px 0}
  h2{font-size:15px;margin:0 0 8px}
  .wrap{max-width:1280px;margin:0 auto;padding:16px 16px 32px}
  .grid{display:grid;gap:12px}
  .g2{grid-template-columns:minmax(0,0.38fr) minmax(0,0.62fr)}
  .card{
    background:var(--card);
    border:1px solid var(--line);
    border-radius:14px;
    padding:14px;
  }
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .col{display:flex;flex-direction:column;gap:6px}
  .small{font-size:12px;color:var(--muted)}
  button{
    border:1px solid var(--line);
    background:#ffffff;
    color:var(--fg);
    padding:7px 11px;
    border-radius:10px;
    cursor:pointer;
    font-size:13px;
  }
  button.primary{background:var(--accent);color:#ffffff;border-color:var(--accent)}
  button:disabled{opacity:.6;cursor:not-allowed}
  input[type="file"]{font-size:13px}
  input[type="text"], select{
    padding:8px 10px;
    border:1px solid var(--line);
    border-radius:10px;
    font-size:13px;
  }
  input[type="text"]{width:100%}
  .status{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid var(--line);
    background:#ffffff;
    font-size:12px;
    margin-top:6px;
  }
  .status.ok{border-color:var(--ok);color:var(--ok);background:#ecfdf5}
  .status.warn{border-color:var(--warn);color:var(--warn);background:#fffbeb}
  .status.err{border-color:var(--err);color:var(--err);background:#fef2f2}
  .tag{
    display:inline-flex;
    align-items:center;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--line);
    font-size:11px;
    background:#ffffff;
    margin-right:6px;
  }
  .tag.primary{border-color:var(--accent);color:var(--accent);background:var(--accent-soft)}
  .tag.ok{border-color:var(--ok);color:var(--ok);background:#ecfdf5}
  .tag.warn{border-color:var(--warn);color:var(--warn);background:#fffbeb}
  .list{
    max-height:320px;
    overflow:auto;
    border:1px solid var(--line);
    border-radius:10px;
    background:#ffffff;
  }
  .rowline{
    display:flex;
    align-items:flex-start;
    gap:10px;
    padding:8px 10px;
    border-bottom:1px solid var(--line);
  }
  .rowline:last-child{border-bottom:none}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Courier New",monospace}
  .trim{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  table{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  th,td{
    border-bottom:1px solid var(--line);
    padding:5px 6px;
    text-align:left;
    vertical-align:top;
  }
  th{background:#f1f5f9;position:sticky;top:0;z-index:1}
  .field-name{font-weight:500}
  .field-type{font-size:11px;color:var(--muted)}

  .step-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-top:16px;
    margin-bottom:4px;
  }
  .step-header-title{
    font-size:13px;
    font-weight:600;
    color:var(--muted);
  }
  .step-toggle{
    font-size:11px;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid var(--line);
    background:#ffffff;
  }
  .hidden-block{display:none !important;}

  .toast-container{
    position:fixed;
    bottom:18px;
    right:18px;
    display:flex;
    flex-direction:column;
    gap:8px;
    z-index:9999;
  }
  .toast{
    background:#0f172a;
    color:#ffffff;
    padding:10px 14px;
    border-radius:10px;
    box-shadow:0 6px 24px rgba(0,0,0,0.16);
    font-size:13px;
    opacity:0.95;
  }

  .active-row{
    border-left:4px solid var(--accent);
    background:#f8fbff;
  }
  .active-row-soft{
    border-left:4px solid var(--accent);
    background:#f5f5ff;
  }

  .filter-row{
    width:100%;
    align-items:flex-start;
  }
  .filter-row .filter-field,
  .filter-row .filter-op{
    min-width:140px;
  }
  .filter-row .filter-value{
    min-width:160px;
    flex:1 1 auto;
  }

  .btn-icon{
    width:26px;
    height:26px;
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0;
    font-size:16px;
    line-height:1;
  }
  .btn-add{
    border-color:#16a34a;
    color:#16a34a;
    background:#ecfdf5;
  }
  .btn-del{
    border-color:#dc2626;
    color:#dc2626;
    background:#fef2f2;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Локальный просмотр открытых данных: list.xml → inspection-YYYY-M.xml → ZIP/XML с проверками</h1>

    <div id="status" class="status">Готово</div>

    <div class="card" style="margin-top:10px">
      <div class="row step-header">
        <span class="step-header-title">Инструкция по использованию</span>
        <button type="button" class="step-toggle" data-toggle="guideBody">Свернуть</button>
      </div>
      <div id="guideBody" class="small">
        Инструкция:
        <ol>
          <li>Нажмите «Перейти на сайт и скачать list.xml» и скачайте файл.</li>
          <li>Загрузите list.xml в блок «Исходный список».</li>
          <li>Выберите интересующий набор (месяц или год).</li>
          <li>Скачайте соответствующий месячный/годовой XML на сайте.</li>
          <li>Загрузите его в блок «Месячный файл» (или «Годовой файл»).</li>
          <li>Выберите нужную версию отчёта (ZIP).</li>
          <li>Распакуйте ZIP и загрузите XML-файл данных в блок «Отчёт с данными».</li>
        </ol>
      </div>
    </div>

  <!-- Шаг 1 -->
  <div class="step">
    <div class="row step-header">
      <span class="step-header-title">Шаг 1. Исходный список (list.xml)</span>
      <button type="button" class="step-toggle" data-toggle="step1Body">Свернуть</button>
    </div>

    <div class="grid g2" id="step1Body">
      <div class="card">
        <h2>Исходный список (list.xml)</h2>
        <div class="small" id="currentDatasetInfo">Текущий набор не выбран</div>
        <div class="small">
          Загрузите файл <span class="mono">list.xml</span> (мастер-список наборов). Система распарсит элементы
          <span class="mono">&lt;item&gt;</span> и покажет доступные месяцы/планы с их ссылками.
        </div>
        <div class="row" style="margin-top:8px">
          <input type="file" id="fileListInput" accept=".xml"/>
          <button id="btnListDownload" type="button">Перейти и скачать list.xml</button>
          <button id="btnClearList">Сбросить list.xml</button>
        </div>
        <div class="small" id="listFileStatus" style="margin-top:4px"></div>
      </div>

      <div class="card">
        <h2>Список наборов из list.xml</h2>
        <div id="listItemsBox" class="list">
          <div class="rowline small">Файл list.xml не загружен</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Шаг 2 -->
  <div class="step">
    <div class="row step-header">
      <span class="step-header-title">Шаг 2. Месячный файл (inspection-YYYY-M.xml)</span>
      <button type="button" class="step-toggle" data-toggle="step2Body">Свернуть</button>
    </div>

    <div class="grid g2" id="step2Body">
      <div class="card">
        <h2>Месячный файл</h2>
        <div class="small" id="currentDatasetInfoStep2">Текущий набор не выбран</div>
        <div class="small">
          Загрузите файл вида <span class="mono">7710146102-inspection-2025-6.xml</span>.
          Он содержит метаданные по месяцу и перечень версий отчёта (<span class="mono">&lt;dataversion&gt;</span>).
        </div>
        <div class="row" style="margin-top:8px">
          <input type="file" id="fileMetaInput" accept=".xml"/>
          <button id="btnClearMeta">Сбросить месячный файл</button>
        </div>
        <div id="metaInfoBox" class="list" style="margin-top:8px">
          <div class="rowline small">Месячный файл не загружен</div>
        </div>
      </div>

      <div class="card">
        <h2>Версии отчёта (dataversion)</h2>
        <div class="small">
          Отображаются строки <span class="mono">&lt;dataversion&gt;</span> из месячного файла:
          дата выгрузки, описание и ссылка на ZIP с данными. Из интерфейса можно только копировать ссылку.
        </div>
        <div id="metaVersionsBox" class="list" style="margin-top:8px">
          <div class="rowline small">Нет данных о версиях — загрузите месячный файл</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Шаг 3 -->
  <div class="step">
    <div class="row step-header">
      <span class="step-header-title">Шаг 3. Отчёт с данными (ZIP/XML)</span>
      <button type="button" class="step-toggle" data-toggle="step3Body">Свернуть</button>
    </div>

    <div class="grid g2" id="step3Body">
      <div class="card">
        <h2>Отчёт с данными</h2>
        <div id="dataContext" class="status" style="margin-bottom:8px"></div>
        <div class="small">
          Загрузите ZIP с данными или уже распакованный XML-файл отчёта. <br>
          Для очень больших XML (например, 400 МБ) система автоматически возьмёт только выборку первых
          записей <span class="mono">&lt;INSPECTION&gt;</span>, не строя DOM для всего файла.
        </div>
        <div class="row" style="margin-top:8px">
          <input type="file" id="fileDataInput" accept=".xml,.zip"/>
          <button id="btnClearData">Сбросить отчёт</button>
        </div>
        <div id="dataSummaryBox" class="list" style="margin-top:8px">
          <div class="rowline small">Отчёт не загружен</div>
        </div>
      </div>

      <div class="card">
        <h2>Доступные поля и столбцы таблицы</h2>
        <div class="small">
          На основе первых записей INSPECTION определяется список полей с примером значения и предполагаемым типом.
        </div>
        <div id="fieldsBox" class="list" style="margin-top:8px;max-height:220px">
          <div class="rowline small">Поля будут видны после загрузки отчёта</div>
        </div>

        <div class="small" style="margin-top:8px">
          Отображение столбцов в таблице предпросмотра (по умолчанию включены все).
        </div>
        <div id="columnsBox" class="list" style="margin-top:4px;max-height:160px">
          <div class="rowline small">Список столбцов появится после загрузки отчёта</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Фильтры и предпросмотр -->
  <div class="card" style="margin-top:12px">
    <div class="row step-header">
      <span class="step-header-title">Фильтры по полям и полнотекстовый поиск</span>
      <button type="button" class="step-toggle" data-toggle="filtersControls">Свернуть фильтры</button>
    </div>

    <div id="filtersControls">
      <div class="small" style="margin-bottom:8px">
        Можно добавлять несколько фильтров по полям (логика «И») и общий полнотекстовый фильтр.
      </div>

      <div class="row" style="margin-bottom:8px">
        <div class="col" style="flex:1 1 auto;min-width:260px">
          <span class="small">Фильтры по полям</span>
          <div id="filtersContainer"></div>
          <button id="btnAddFilter" type="button" class="btn-icon btn-add" title="Добавить фильтр">+</button>
        </div>
      </div>

      <div class="row" style="margin-bottom:8px">
        <div class="col" style="flex:1 1 auto;min-width:200px">
          <span class="small">Полнотекстовый фильтр</span>
          <input type="text" id="fullTextFilter" placeholder="поиск по всей записи (часть названия, адрес и т.п.)"/>
        </div>
      </div>

      <div class="row" style="margin-bottom:8px">
        <button id="btnPreview" class="primary" disabled>Показать</button>
        <button id="btnExport" disabled>Экспорт JSON</button>
        <button id="btnExportCsv" disabled>Экспорт CSV</button>
        <button id="btnClearFilters">Сбросить фильтры</button>
      </div>
    </div>

    <div class="row" style="justify-content:flex-end;margin-bottom:4px;margin-top:4px">
      <span class="small" style="margin-right:6px">Количество записей</span>
      <select id="previewCount">
        <option value="10">10</option>
        <option value="50">50</option>
        <option value="100">100</option>
        <option value="1000">1000</option>
        <option value="all">Все (осторожно)</option>
      </select>
    </div>

    <div id="previewBox" class="list" style="max-height:360px">
      <div class="rowline small">Предпросмотр будет доступен после загрузки отчёта</div>
    </div>
  </div>
  <div id="toastContainer" class="toast-container"></div>
</div>

<script>
const $ = s => document.querySelector(s);

/* Человекочитаемые названия полей */
const CUSTOM_FIELD_LABELS = {
  'INSPECTION.CreationSource': 'Источник формирования записи',
  'INSPECTION.ERPID': 'Идентификатор проверки (ERPID)',
  'INSPECTION.ITYPE_NAME': 'Вид проверки',
  'INSPECTION.FZ_NAME': 'Закон (ФЗ)',
  'INSPECTION.PROSEC_NAME': 'Орган прокуратуры',
  'INSPECTION.START_DATE': 'Дата начала проверки',
  'INSPECTION.STATUS': 'Статус проверки',

  'INSPECTION.OKATO.OKATO_RAZDEL': 'Раздел ОКАТО',
  'INSPECTION.OKATO.OKATO_KOD2': 'ОКАТО, код 2',
  'INSPECTION.OKATO.OKATO_KOD3': 'ОКАТО, код 3',

  'INSPECTION.I_OBJECT.ADDRESS': 'Адрес объекта проверки',
  'INSPECTION.I_OBJECT.ADDRESS_TYPE_NAME': 'Тип адреса объекта',
  'INSPECTION.I_OBJECT.IOBJECT_TYPE_NAME': 'Тип объекта проверки',

  'INSPECTION.I_OBJECT.I_RESULT.ACT_DATE_CREATE': 'Дата составления акта',
  'INSPECTION.I_OBJECT.I_RESULT.ACT_ADDRESS': 'Адрес в акте',
  'INSPECTION.I_OBJECT.I_RESULT.ACT_ADDRESS_TYPE_NAME': 'Тип адреса в акте',
  'INSPECTION.I_OBJECT.I_RESULT.START_DATE': 'Дата начала мероприятия по объекту',
  'INSPECTION.I_OBJECT.I_RESULT.DURATION_DAYS': 'Длительность по объекту (дни)',

  'INSPECTION.I_OBJECT.I_RESULT.I_RESULT_INSPECTOR.FULL_NAME': 'ФИО инспектора (по объекту)',
  'INSPECTION.I_OBJECT.I_RESULT.I_RESULT_INSPECTOR.POSITION': 'Должность инспектора (по объекту)',
  'INSPECTION.I_OBJECT.I_RESULT.I_RESULT_INSPECTOR.INSPECTOR_TYPE_NAME': 'Тип инспектора (по объекту)',

  'INSPECTION.I_OBJECT.I_RESULT.I_RESULT_INFORMATION.RESULT_INFORMATION_TYPE_NAME': 'Вид сведений о результате',
  'INSPECTION.I_OBJECT.I_RESULT.I_RESULT_INFORMATION.TEXT': 'Текст сведений о результате',

  'INSPECTION.I_OBJECT.I_SUPERVISION.ISUPERVISION_NAME': 'Вид контроля (надзора) по объекту',

  'INSPECTION.I_SUBJECT.ISUBJECT_TYPE_NAME': 'Тип субъекта проверки',
  'INSPECTION.I_SUBJECT.ORG_NAME': 'Наименование субъекта',
  'INSPECTION.I_SUBJECT.INN': 'ИНН субъекта',
  'INSPECTION.I_SUBJECT.OGRN': 'ОГРН субъекта',
  'INSPECTION.I_SUBJECT.DATE_REG': 'Дата регистрации субъекта',

  'INSPECTION.I_CLASSIFICATION.ICARRYOUT_TYPE_NAME': 'Вид проведения проверки',
  'INSPECTION.I_CLASSIFICATION.ISUPERVISION_NAME': 'Вид контроля (надзора) (классификация)',
  'INSPECTION.I_CLASSIFICATION.INOTICE_TYPE_NAME': 'Вид уведомления',
  'INSPECTION.I_CLASSIFICATION.INOTICE_DATE': 'Дата уведомления',

  'INSPECTION.I_AUTHORITY.FRGU_ORG_ID_BK': 'Идентификатор органа в ФРГУ',
  'INSPECTION.I_AUTHORITY.FRGU_ORG_NAME': 'Наименование органа в ФРГУ',
  'INSPECTION.I_AUTHORITY.FRGU_ORG_OGRN': 'ОГРН органа в ФРГУ',
  'INSPECTION.I_AUTHORITY.FRGU_ORG_PARENT_ID_BK': 'Идентификатор вышестоящего органа в ФРГУ',
  'INSPECTION.I_AUTHORITY.I_AUTHORITY_SERV.FRGU_SERV_ID_BK': 'Идентификатор услуги в ФРГУ',
  'INSPECTION.I_AUTHORITY.I_AUTHORITY_SERV.FRGU_SERV_NAME': 'Наименование услуги в ФРГУ',

  'INSPECTION.I_INSPECTOR.FULL_NAME': 'ФИО инспектора',
  'INSPECTION.I_INSPECTOR.POSITION': 'Должность инспектора',
  'INSPECTION.I_INSPECTOR.INSPECTOR_TYPE_NAME': 'Тип инспектора',

  'INSPECTION.I_APPROVE.IS_START_DATE_AS_MONTH': 'Дата начала как месяц (признак)',
  'INSPECTION.I_APPROVE.DURATION_DAY': 'Согласованный срок проверки (дни)',
  'INSPECTION.I_APPROVE.IS_APPROVED': 'Проверка согласована (признак)',
  'INSPECTION.I_APPROVE.INSP_TARGET': 'Цель проверки',

  'INSPECTION.I_APPROVE.I_CARRYOUT_EVENTS.EVENTS_TEXT': 'Текст планируемых мероприятий',
  'INSPECTION.I_APPROVE.I_CARRYOUT_EVENTS.START_DATE': 'Дата начала мероприятий',
  'INSPECTION.I_APPROVE.I_CARRYOUT_EVENTS.END_DATE': 'Дата окончания мероприятий',

  'INSPECTION.I_APPROVE.I_REASON.IREASON_NAME': 'Основание проведения проверки',
  'INSPECTION.I_APPROVE.I_REASON.REASON_DATE': 'Дата основания проверки',
  'INSPECTION.I_APPROVE.I_REASON.IS_APPROVE_REQUIRED': 'Требуется согласование (признак)',

  'INSPECTION.I_APPROVE.I_APPROVE_DOCS.IAPPROVE_DOC_NAME': 'Документ согласования — наименование',
  'INSPECTION.I_APPROVE.I_APPROVE_DOCS.DOC_ATR': 'Документ согласования — реквизиты',
  'INSPECTION.I_APPROVE.I_APPROVE_DOCS.DOC_DATE': 'Документ согласования — дата',

  'INSPECTION.I_CLASSIFICATION_LB.LB_DOCUMENT_NAME': 'НПА, устанавливающий обязательные требования',

  'INSPECTION.requirements.requirementName': 'Наименование требования',
  'INSPECTION.requirements.documents.templateRequirementName': 'Шаблон требования: наименование',
  'INSPECTION.requirements.documents.templateRequirementProps': 'Шаблон требования: реквизиты',
  'INSPECTION.requirements.documents.templateRequirementNumber': 'Шаблон требования: номер',
  'INSPECTION.requirements.documents.templateRequirementDate': 'Шаблон требования: дата'
};

function displayFieldName(key){
  const human = CUSTOM_FIELD_LABELS[key];
  return human ? (human + ' (' + key + ')') : key;
}

function setStatus(text, level){
  const el = $('#status');
  el.textContent = text;
  el.className = 'status';
  if(level==='ok') el.classList.add('ok');
  else if(level==='warn') el.classList.add('warn');
  else if(level==='err') el.classList.add('err');
}

function showToast(text){
  const cont = $('#toastContainer');
  if(!cont) return;
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = text;
  cont.appendChild(toast);
  setTimeout(() => {
    toast.remove();
  }, 1500);
}

function escapeHtml(s){
  return (s ?? '').replace(/[&<>"']/g, m => ({
    '&':'&amp;',
    '<':'&lt;',
    '>':'&gt;',
    '"':'&quot;',
    "'":'&#39;'
  })[m]);
}

function parseXml(text){
  const p = new DOMParser();
  const doc = p.parseFromString(text, 'application/xml');
  if(doc.querySelector('parsererror')) throw new Error('Ошибка парсинга XML (возможно, выборка обрезана некорректно)');
  return doc;
}

function getText(root, tagName){
  const el = root.getElementsByTagName(tagName)[0];
  return el ? (el.textContent || '').trim() : '';
}

/* Шаг 1: list.xml */

let listItems = [];
let activeDataset = null;
let activeVersion = null;
let lastDataFileName = '';

function setActiveDataset(title, identifier){
  if(title){
    activeDataset = {title: (title || '').trim(), identifier: (identifier || '').trim()};
  }else{
    activeDataset = null;
  }
  if(!activeDataset) activeVersion = null;
  updateDatasetLabels();
  renderListItems();
  renderMetaVersions();
  renderDataContext();
}

function updateDatasetLabels(){
  const txt = activeDataset ? `Текущий набор: ${activeDataset.title || '(без названия)'}` : 'Текущий набор не выбран';
  const el1 = $('#currentDatasetInfo');
  const el2 = $('#currentDatasetInfoStep2');
  if(el1) el1.textContent = txt;
  if(el2) el2.textContent = txt;
}

function setActiveVersion(v){
  activeVersion = v ? {...v} : null;
  renderMetaVersions();
  renderDataContext();
}

function renderDataContext(){
  const box = $('#dataContext');
  if(!box) return;
  const parts = [];
  if(activeDataset){
    parts.push(`Набор: ${escapeHtml(activeDataset.title || '(без названия)')}`);
  }else{
    parts.push('Набор: не выбран');
  }
  if(activeVersion){
    parts.push(`Версия отчёта: ${escapeHtml(activeVersion.created || '(дата не указана)')} — ${escapeHtml(activeVersion.prov || '')}`);
  }else{
    parts.push('Версия отчёта: не выбрана');
  }
  if(lastDataFileName){
    parts.push(`Файл: ${escapeHtml(lastDataFileName)}`);
  }else{
    parts.push('Файл: не загружен');
  }

  box.className = 'status';
  if(activeDataset && activeVersion && lastDataFileName){
    box.classList.add('ok');
  }else{
    box.classList.add('warn');
    parts.push('Файл не привязан к выбранному набору или версии отчёта.');
  }
  box.innerHTML = parts.map(p => `<div>${p}</div>`).join('');
}

updateDatasetLabels();
renderDataContext();

$('#fileListInput').addEventListener('change', async e => {
  const file = e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const doc = parseXml(text);
    const listEl = doc.getElementsByTagName('list')[0];
    const items = listEl ? Array.from(listEl.getElementsByTagName('item')) : [];
    listItems = items.map(it => ({
      identifier: it.getAttribute('identifier') || '',
      title: it.getAttribute('title') || '',
      link: it.getAttribute('link') || '',
      format: it.getAttribute('format') || ''
    }));
    renderListItems();
    $('#listFileStatus').textContent = 'Загружен файл: list.xml (локальный)';
    setStatus('list.xml загружен, найдено элементов: ' + listItems.length, 'ok');
  }catch(err){
    listItems = [];
    renderListItems();
    setStatus('Ошибка при обработке list.xml: ' + err.message, 'err');
  }
});

$('#btnClearList').addEventListener('click', () => {
  $('#fileListInput').value = '';
  listItems = [];
  renderListItems();
  $('#listFileStatus').textContent = '';
  setStatus('list.xml сброшен', 'ok');
});

$('#btnListDownload').addEventListener('click', () => {
  window.open('https://proverki.gov.ru/portal/public-open-data', '_blank');
});

function renderListItems(){
  const box = $('#listItemsBox');
  box.innerHTML = '';
  if(!listItems.length){
    box.innerHTML = '<div class="rowline small">Файл list.xml не загружен или в нём нет элементов &lt;item&gt;</div>';
    return;
  }
  listItems.forEach(item => {
    const isActive = activeDataset && (
      (activeDataset.identifier && activeDataset.identifier === item.identifier) ||
      (activeDataset.title && activeDataset.title.toLowerCase() === (item.title || '').trim().toLowerCase())
    );
    const row = document.createElement('div');
    row.className = 'rowline' + (isActive ? ' active-row' : '');
    row.innerHTML = `
      <div style="flex:1 1 auto;min-width:0">
        <div class="trim"><b>${escapeHtml(item.title || '(без названия)')}</b></div>
        <div class="small mono trim">${escapeHtml(item.link || '')}</div>
        <div class="small">
          Идентификатор: <span class="mono">${escapeHtml(item.identifier || '-')}</span>,
          формат: <span class="mono">${escapeHtml(item.format || '-')}</span>
        </div>
      </div>
      <div class="row" style="flex:0 0 auto">
        <button data-copy>Копировать ссылку</button>
        <button data-open>Перейти</button>
      </div>
    `;
    row.querySelector('[data-copy]').addEventListener('click', () => {
      if(item.link){
        navigator.clipboard?.writeText(item.link).then(
          () => showToast('Скопировано'),
          () => setStatus('Не удалось скопировать ссылку', 'warn')
        );
      }else{
        setStatus('У элемента нет ссылки link', 'warn');
      }
    });
    row.querySelector('[data-open]').addEventListener('click', () => {
      if(item.link){
        window.open(item.link, '_blank');
      }else{
        setStatus('У элемента нет ссылки link', 'warn');
      }
    });
    box.appendChild(row);
  });
}

/* Шаг 2: месячный inspection-YYYY-M.xml */

let metaVersions = [];

$('#fileMetaInput').addEventListener('change', async e => {
  const file = e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const doc = parseXml(text);
    const metaSummary = renderMetaInfo(doc);
    setActiveDataset(metaSummary.title, metaSummary.identifier);
    setActiveVersion(null);
    metaVersions = extractMetaVersions(doc);
    renderMetaVersions();
    setStatus('Месячный файл загружен, версий отчёта: ' + metaVersions.length, 'ok');
  }catch(err){
    metaVersions = [];
    renderMetaInfo(null);
    setActiveDataset(null);
    renderMetaVersions();
    setStatus('Ошибка при обработке месячного файла: ' + err.message, 'err');
  }
});

$('#btnClearMeta').addEventListener('click', () => {
  $('#fileMetaInput').value = '';
  metaVersions = [];
  renderMetaInfo(null);
  renderMetaVersions();
  setActiveDataset(null);
  setStatus('Месячный файл сброшен', 'ok');
});

function renderMetaInfo(doc){
  const box = $('#metaInfoBox');
  box.innerHTML = '';
  if(!doc){
    box.innerHTML = '<div class="rowline small">Месячный файл не загружен</div>';
    return {title:'', identifier:''};
  }
  const rootMeta = doc.getElementsByTagName('meta')[0] || doc.documentElement;
  const title = getText(rootMeta, 'title');
  const desc = getText(rootMeta, 'description');
  const creator = getText(rootMeta, 'creator');
  const subject = getText(rootMeta, 'subject');
  const format = getText(rootMeta, 'format');
  const identifier = getText(rootMeta, 'identifier');
  const structure = doc.getElementsByTagName('structureversion')[0];
  const strVer = structure ? (structure.textContent || '').trim() : '';
  const strCreated = getText(doc, 'created');
  const row = document.createElement('div');
  row.className = 'rowline';
  row.style.flexDirection = 'column';
  row.innerHTML = `
    <div><span class="tag primary">Месячный файл</span><b>${escapeHtml(title || '(без названия)')}</b></div>
    <div class="small">Создатель: ${escapeHtml(creator || '-')}</div>
    <div class="small">Тема: ${escapeHtml(subject || '-')}</div>
    <div class="small">Формат: <span class="mono">${escapeHtml(format || '-')}</span></div>
    <div class="small">Идентификатор набора: <span class="mono">${escapeHtml(identifier || '-')}</span></div>
    <div class="small">Версия структуры: <span class="mono">${escapeHtml(strVer || '-')}</span>,
      создано/обновлено: <span class="mono">${escapeHtml(strCreated || '-')}</span></div>
    <div class="small" style="margin-top:4px">${escapeHtml(desc || '')}</div>
  `;
  box.appendChild(row);
  return {title, identifier};
}

function extractMetaVersions(doc){
  const res = [];
  const dataEl = doc.getElementsByTagName('data')[0];
  if(!dataEl) return res;
  const vers = Array.from(dataEl.getElementsByTagName('dataversion'));
  vers.forEach(v => {
    const source = getText(v, 'source');
    const created = getText(v, 'created');
    const prov = getText(v, 'provenance');
    if(source){
      res.push({source, created, prov});
    }
  });
  return res;
}

function renderMetaVersions(){
  const box = $('#metaVersionsBox');
  box.innerHTML = '';
  if(!metaVersions.length){
    box.innerHTML = '<div class="rowline small">Нет элементов &lt;dataversion&gt; или месячный файл не загружен</div>';
    return;
  }
  metaVersions.forEach(v => {
    const isActive = activeVersion && activeVersion.source === v.source && activeVersion.created === v.created;
    const row = document.createElement('div');
    row.className = 'rowline' + (isActive ? ' active-row-soft' : '');
    row.innerHTML = `
      <div style="flex:1 1 auto;min-width:0">
        <div><b>${escapeHtml(v.created || '(дата не указана)')}</b></div>
        <div class="small">${escapeHtml(v.prov || '(нет описания)')}</div>
        <div class="small mono trim">${escapeHtml(v.source)}</div>
      </div>
      <div class="row" style="flex:0 0 auto">
        <button data-select>Выбрать версию</button>
        <button data-copy>Копировать ссылку</button>
      </div>
    `;
    row.querySelector('[data-copy]').addEventListener('click', () => {
      if(v.source){
        navigator.clipboard?.writeText(v.source).then(
          () => showToast('Скопировано'),
          () => setStatus('Не удалось скопировать ссылку', 'warn')
        );
      }else{
        setStatus('У версии нет ссылки source', 'warn');
      }
    });
    row.querySelector('[data-select]').addEventListener('click', () => {
      setActiveVersion(v);
    });
    box.appendChild(row);
  });
}

/* Шаг 3: отчёт (ZIP/XML) */

let recordNodes = [];
let recordTagName = '';
let fieldInfoMap = new Map();
let previewCache = [];
let fieldKeys = [];
let fieldValueSamples = new Map();      // поле → массив уникальных значений
let columnVisibility = new Map();       // поле → true/false
let lastPreviewColumns = [];            // столбцы, реально выведенные в последнем предпросмотре

function renderDataSummary(){
  const box = $('#dataSummaryBox');
  box.innerHTML = '';
  if(!recordNodes.length){
    box.innerHTML = '<div class="rowline small">Отчёт не загружен или структура не распознана</div>';
    return;
  }
  const row = document.createElement('div');
  row.className = 'rowline';
  row.style.flexDirection = 'column';
  row.innerHTML = `
    <div>
      <span class="tag ok">Активный отчёт</span>
      Обнаружен контейнер <span class="mono">${escapeHtml(recordTagName)}</span>
      с количеством записей в выборке: <b>${recordNodes.length}</b>.
    </div>
    <div class="small" style="margin-top:4px">
      Для предпросмотра используются плоские объекты с ключами вида
      <span class="mono">INSPECTION.I_SUBJECT.INN</span>,
      <span class="mono">INSPECTION.I_OBJECT.ADDRESS</span> и т.п.
    </div>
  `;
  box.appendChild(row);
}

function renderFields(){
  const box = $('#fieldsBox');
  box.innerHTML = '';
  if(!fieldInfoMap.size){
    box.innerHTML = '<div class="rowline small">Поля будут видны после загрузки и анализа отчёта</div>';
    return;
  }
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr>
      <th style="width:40%">Поле</th>
      <th style="width:20%">Тип</th>
      <th>Пример значения</th>
    </tr>
  `;
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  for(const [key, meta] of fieldInfoMap.entries()){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="field-name mono">${escapeHtml(displayFieldName(key))}</td>
      <td class="field-type">${escapeHtml(meta.type || 'строка')}</td>
      <td>${escapeHtml(meta.sample ?? '')}</td>
    `;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  box.appendChild(table);

  fieldKeys = Array.from(fieldInfoMap.keys());
  setupColumnVisibility();
  resetFiltersUI();
  updateFilterFieldOptions();
  refreshAllFilterDatalists();
}

function renderColumnsBox(){
  const box = $('#columnsBox');
  box.innerHTML = '';
  if(!fieldKeys.length){
    box.innerHTML = '<div class="rowline small">Список столбцов появится после загрузки отчёта</div>';
    return;
  }
  fieldKeys.forEach(key => {
    const row = document.createElement('div');
    row.className = 'rowline';
    const label = document.createElement('label');
    label.className = 'small';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = columnVisibility.get(key) !== false;
    cb.dataset.col = key;
    cb.style.marginRight = '6px';
    label.appendChild(cb);
    label.appendChild(document.createTextNode(displayFieldName(key)));
    row.appendChild(label);
    box.appendChild(row);

    cb.addEventListener('change', () => {
      columnVisibility.set(key, cb.checked);
      if(previewCache.length){
        renderPreviewTable(previewCache);
      }
    });
  });
}

function setupColumnVisibility(){
  columnVisibility.clear();
  fieldKeys.forEach(k => columnVisibility.set(k, true));
  renderColumnsBox();
}

function clearDataState(){
  recordNodes = [];
  recordTagName = '';
  fieldInfoMap.clear();
  previewCache = [];
  fieldKeys = [];
  fieldValueSamples.clear();
  columnVisibility.clear();
  lastPreviewColumns = [];
  lastDataFileName = '';
  renderDataSummary();
  renderFields();
  renderColumnsBox();
  renderPreviewPlaceholder();
  $('#btnPreview').disabled = true;
  $('#btnExport').disabled = true;
  $('#btnExportCsv').disabled = true;
  resetFiltersUI();
  renderDataContext();
}

$('#fileDataInput').addEventListener('change', async e => {
  const file = e.target.files[0];
  if(!file) return;
  try{
    lastDataFileName = file.name;
    renderDataContext();
    await loadDataFileSmart(file);
  }catch(err){
    clearDataState();
    setStatus('Ошибка при обработке отчёта: ' + err.message, 'err');
  }
});

$('#btnClearData').addEventListener('click', () => {
  $('#fileDataInput').value = '';
  clearDataState();
  setStatus('Отчёт сброшен', 'ok');
});

/* ZIP/не ZIP */

function isZip(u8){
  return u8.length >= 4 &&
    u8[0] === 0x50 && u8[1] === 0x4B && u8[2] === 0x03 && u8[3] === 0x04;
}

async function unzip(u8){
  function dv(u, off, len){ return new DataView(u.buffer, u.byteOffset + off, len); }
  function u16(v, o){ return v.getUint16(o, true); }
  function u32(v, o){ return v.getUint32(o, true); }
  function sig(u, off){ return u32(dv(u, off, 4), 0); }

  let eocd = -1;
  for(let i = u8.length - 22; i >= 0; i--){
    if(sig(u8, i) === 0x06054b50){ eocd = i; break; }
  }
  if(eocd < 0) throw new Error('ZIP: EOCD не найден');
  const vEO = dv(u8, eocd, 22);
  const entries = u16(vEO, 10);
  const cdOffset = u32(vEO, 16);
  const out = {};
  let p = cdOffset;

  for(let i = 0; i < entries; i++){
    if(sig(u8, p) !== 0x02014b50) throw new Error('ZIP: повреждён центральный каталог');
    const v = dv(u8, p, 46);
    const nameLen = u16(v, 28);
    const extraLen = u16(v, 30);
    const cmntLen = u16(v, 32);
    const lhoff = u32(v, 42);
    const name = new TextDecoder().decode(u8.subarray(p + 46, p + 46 + nameLen));
    p += 46 + nameLen + extraLen + cmntLen;

    if(sig(u8, lhoff) !== 0x04034b50) throw new Error('ZIP: повреждён локальный заголовок');
    const vh = dv(u8, lhoff, 30);
    const method = u16(vh, 8);
    const nLen = u16(vh, 26);
    const xLen = u16(vh, 28);
    const dataStart = lhoff + 30 + nLen + xLen;

    const compSize = u32(v, 20);
    const comp = u8.subarray(dataStart, dataStart + compSize);

    if(method === 0){
      out[name] = comp;
    }else if(method === 8){
      if(typeof DecompressionStream === 'undefined'){
        throw new Error('Браузер не поддерживает распаковку deflate (DecompressionStream)');
      }
      const stream = new DecompressionStream('deflate-raw');
      const ab = await new Response(new Blob([comp]).stream().pipeThrough(stream)).arrayBuffer();
      out[name] = new Uint8Array(ab);
    }
  }
  return out;
}

/* Загрузка отчёта с учётом больших XML */

async function loadDataFileSmart(file){
  clearDataState();
  lastDataFileName = file.name || '';
  renderDataContext();

  const sizeMB = (file.size / (1024*1024)).toFixed(1);
  const bufHead = await file.slice(0, 8).arrayBuffer();
  const u8Head = new Uint8Array(bufHead);

  if(isZip(u8Head)){
    const fullBuf = await file.arrayBuffer();
    const u8 = new Uint8Array(fullBuf);
    const files = await unzip(u8);
    const xmlNames = Object.keys(files).filter(n => n.toLowerCase().endsWith('.xml'));
    if(!xmlNames.length) throw new Error('В ZIP не найдено XML-файлов');
    const firstName = xmlNames[0];
    const text = new TextDecoder().decode(files[firstName]);
    processDataXmlSmart(text, file.size);
    return;
  }

  const BIG_XML_BYTES = 80 * 1024 * 1024;
  if(file.size > BIG_XML_BYTES){
    const SAMPLE_BYTES = 16 * 1024 * 1024;
    const slice = file.slice(0, SAMPLE_BYTES);
    const buf = await slice.arrayBuffer();
    const text = new TextDecoder().decode(new Uint8Array(buf));
    setStatus(
      'Большой XML (' + sizeMB + ' МБ). Для анализа полей и предпросмотра используется выборка ' +
      'первых INSPECTION из первых ~' + (SAMPLE_BYTES/1024/1024).toFixed(1) + ' МБ файла.',
      'warn'
    );
    processDataXmlSample(text);
  }else{
    const buf = await file.arrayBuffer();
    const text = new TextDecoder().decode(new Uint8Array(buf));
    processDataXmlSmart(text, file.size);
  }
}

function processDataXmlSmart(text, origSizeBytes){
  const BIG_TEXT_CHARS = 50 * 1024 * 1024;
  if(text.length > BIG_TEXT_CHARS){
    const sizeMB = (origSizeBytes / (1024*1024)).toFixed(1);
    setStatus(
      'Файл XML после распаковки очень большой (~' + sizeMB +
      ' МБ текста). Используется выборка первых INSPECTION.',
      'warn'
    );
    processDataXmlSample(text);
  }else{
    processDataXmlSmall(text);
  }
}

/* Нормальный путь для небольших файлов */

function processDataXmlSmall(text){
  const doc = parseXml(text);
  const root = doc.documentElement;
  const candNodes = detectRepeater(root);
  recordNodes = candNodes.nodes;
  recordTagName = candNodes.tagName;
  if(!recordNodes.length) throw new Error('Не удалось определить повторяющийся контейнер с записями');

  fieldInfoMap = analyseFields(recordNodes, 200);
  collectFieldValueSamples(recordNodes, 300);
  previewCache = [];
  renderDataSummary();
  renderFields();
  renderPreviewPlaceholder();
  $('#btnPreview').disabled = true ? !recordNodes.length : false;
  $('#btnPreview').disabled = !recordNodes.length;
  $('#btnExport').disabled = true;
  $('#btnExportCsv').disabled = true;
  setStatus('Отчёт загружен, записей в выборке: ' + recordNodes.length, 'ok');
}

/* Путь выборки INSPECTION для огромных файлов */

function processDataXmlSample(text){
  const sample = buildInspectionSampleDoc(text, 2000);
  recordNodes = sample.nodes;
  recordTagName = sample.tagName;
  if(!recordNodes.length) throw new Error('Не удалось найти элементы INSPECTION в первых мегабайтах файла');

  fieldInfoMap = analyseFields(recordNodes, 500);
  collectFieldValueSamples(recordNodes, 300);
  previewCache = [];
  renderDataSummary();
  renderFields();
  renderPreviewPlaceholder();
  $('#btnPreview').disabled = !recordNodes.length;
  $('#btnExport').disabled = true;
  $('#btnExportCsv').disabled = true;
}

/* Собираем мини-документ с первыми N INSPECTION */

function buildInspectionSampleDoc(text, maxRecords){
  const TAG = '<INSPECTION';
  const END_TAG = '</INSPECTION>';
  const parts = [];
  let searchFrom = 0;

  while(parts.length < maxRecords){
    const start = text.indexOf(TAG, searchFrom);
    if(start === -1) break;
    const end = text.indexOf(END_TAG, start);
    if(end === -1) break;
    const frag = text.slice(start, end + END_TAG.length);
    parts.push(frag);
    searchFrom = end + END_TAG.length;
  }

  if(!parts.length){
    return {doc:null, nodes:[], tagName:'INSPECTION'};
  }

  const sampleXml =
    '<?xml version="1.0" encoding="UTF-8"?>' +
    '<ROOT xmlns="https://proverki.gov.ru/opendata/3.0/20210222">' +
    parts.join('') +
    '</ROOT>';

  const doc = parseXml(sampleXml);
  const nodes = Array.from(doc.getElementsByTagName('INSPECTION'));
  return {doc, nodes, tagName:'INSPECTION'};
}

/* Поиск повторяющегося контейнера */

function detectRepeater(root){
  const insp = root.getElementsByTagName('INSPECTION');
  if(insp.length){
    return {tagName:'INSPECTION', nodes:Array.from(insp)};
  }

  const freq = new Map();
  const els = root.getElementsByTagName('*');
  for(const el of els){
    if(el.children && el.children.length){
      const tag = el.tagName;
      freq.set(tag, (freq.get(tag) || 0) + 1);
    }
  }
  let bestTag = '';
  let bestCount = 0;
  freq.forEach((count, tag) => {
    if(count > bestCount){
      bestCount = count;
      bestTag = tag;
    }
  });
  const nodes = bestTag ? Array.from(root.getElementsByTagName(bestTag)) : [];
  return {tagName: bestTag, nodes};
}

/* Анализ полей */

function analyseFields(nodes, limit){
  const map = new Map();
  const max = Math.min(nodes.length, limit || 200);
  for(let i = 0; i < max; i++){
    const flat = flattenNode(nodes[i]);
    for(const [k, v] of Object.entries(flat)){
      if(!map.has(k)){
        const sample = Array.isArray(v) ? v[0] : v;
        map.set(k, {sample, type: detectType(sample)});
      }
    }
  }
  return map;
}

/* Сбор значений для подсказок в фильтрах */

function collectFieldValueSamples(nodes, limit){
  fieldValueSamples.clear();
  const maxRec = Math.min(nodes.length, limit || 300);
  const MAX_PER_FIELD = 200;
  for(let i = 0; i < maxRec; i++){
    const flat = flattenNode(nodes[i]);
    for(const [k, v] of Object.entries(flat)){
      const arr = Array.isArray(v) ? v : [v];
      arr.forEach(val => {
        const s = String(val ?? '').trim();
        if(!s) return;
        let list = fieldValueSamples.get(k);
        if(!list){
          list = [];
          fieldValueSamples.set(k, list);
        }
        if(list.length >= MAX_PER_FIELD) return;
        if(!list.includes(s)) list.push(s);
      });
    }
  }
}

/* Атрибуты + текстовые узлы */

function flattenNode(node){
  const res = {};
  function walk(el, prefix){
    const keyBase = prefix ? prefix : el.tagName;

    if(el.attributes && el.attributes.length){
      Array.from(el.attributes).forEach(attr => {
        const key = keyBase + '.' + attr.name;
        const val = (attr.value || '').trim();
        if(!val) return;
        if(res[key] === undefined) res[key] = val;
        else if(Array.isArray(res[key])) res[key].push(val);
        else res[key] = [res[key], val];
      });
    }

    el.childNodes.forEach(ch => {
      if(ch.nodeType === 1){
        const tag = ch.tagName;
        const nextPrefix = keyBase + '.' + tag;
        walk(ch, nextPrefix);
      }else if(ch.nodeType === 3){
        const val = (ch.textContent || '').trim();
        if(!val) return;
        const key = keyBase + '._text';
        if(res[key] === undefined) res[key] = val;
        else if(Array.isArray(res[key])) res[key].push(val);
        else res[key] = [res[key], val];
      }
    });
  }
  walk(node, '');
  return res;
}

function detectType(sample){
  if(sample == null) return 'строка';
  const s = String(sample).trim();
  if(!s) return 'строка';
  if(/^\d{4}-\d{2}-\d{2}(T.*)?$/.test(s)) return 'дата';
  const n = Number(s.replace(',', '.'));
  if(!Number.isNaN(n) && s.match(/^[-+]?\d+([.,]\d+)?$/)) return 'число';
  return 'строка';
}

/* Фильтры и предпросмотр */

function renderPreviewPlaceholder(){
  const box = $('#previewBox');
  box.innerHTML = '';
  if(!recordNodes.length){
    box.innerHTML = '<div class="rowline small">Предпросмотр будет доступен после загрузки отчёта</div>';
    return;
  }
  box.innerHTML = '<div class="rowline small">Нажмите «Показать», чтобы отфильтровать и вывести записи</div>';
}

/* Управление строками фильтров */

function resetFiltersUI(){
  const cont = $('#filtersContainer');
  cont.innerHTML = '';
  addFilterRow();
}

function addFilterRow(initial){
  const cont = $('#filtersContainer');
  const rowId = 'fr-' + Math.random().toString(16).slice(2);
  const row = document.createElement('div');
  row.className = 'row filter-row';
  row.dataset.rowId = rowId;

  const fieldSel = document.createElement('select');
  fieldSel.className = 'filter-field';
  fieldSel.innerHTML = '<option value="">(поле)</option>';

  const opSel = document.createElement('select');
  opSel.className = 'filter-op';
  opSel.innerHTML = `
    <option value="contains">содержит</option>
    <option value="eq">=</option>
    <option value="ge">&ge;</option>
    <option value="le">&le;</option>
  `;

  const valInput = document.createElement('input');
  valInput.type = 'text';
  valInput.className = 'filter-value';
  valInput.placeholder = 'значение (можно выбрать из списка)';

  const delBtn = document.createElement('button');
  delBtn.type = 'button';
  delBtn.className = 'btn-icon btn-del filter-remove';
  delBtn.textContent = '×';
  delBtn.title = 'Удалить фильтр';

  row.appendChild(fieldSel);
  row.appendChild(opSel);
  row.appendChild(valInput);
  row.appendChild(delBtn);
  cont.appendChild(row);

  // datalist для значений
  const dl = document.createElement('datalist');
  const dlId = 'fv-' + rowId;
  dl.id = dlId;
  document.body.appendChild(dl);
  valInput.setAttribute('list', dlId);
  valInput.dataset.datalistId = dlId;

    delBtn.addEventListener('click', () => {
    const rows = cont.querySelectorAll('.filter-row');
    if(rows.length > 1){
      row.remove();
      const dl = document.getElementById(valInput.dataset.datalistId);
      if(dl) dl.remove();
    }else{
      fieldSel.value = '';
      opSel.value = 'contains';
      valInput.value = '';
      const dl = document.getElementById(valInput.dataset.datalistId);
      if(dl) dl.innerHTML = '';
    }
  });

  fieldSel.addEventListener('change', () => {
    refreshDatalistForRow(row);
  });

  if(initial){
    fieldSel.value = initial.field || '';
    opSel.value = initial.op || 'contains';
    valInput.value = initial.value || '';
  }

  updateFilterFieldOptions();
  refreshDatalistForRow(row);
}

/* Обновление списка полей в селектах фильтров */

function updateFilterFieldOptions(){
  const selects = document.querySelectorAll('.filter-field');
  selects.forEach(sel => {
    const current = sel.value;
    sel.innerHTML = '<option value="">(поле)</option>';
    fieldKeys.forEach(k => {
      const opt = document.createElement('option');
      opt.value = k;
      opt.textContent = displayFieldName(k);
      sel.appendChild(opt);
    });
    if(fieldKeys.includes(current)) sel.value = current;
  });
}

/* Обновление datalist для одной строки фильтра */

function refreshDatalistForRow(row){
  const fieldSel = row.querySelector('.filter-field');
  const valInput = row.querySelector('.filter-value');
  const dlId = valInput.dataset.datalistId;
  const dl = document.getElementById(dlId);
  if(!dl) return;
  dl.innerHTML = '';

  const field = fieldSel.value;
  if(!field) return;

  const values = fieldValueSamples.get(field) || [];
  values.forEach(v => {
    const opt = document.createElement('option');
    opt.value = v;
    dl.appendChild(opt);
  });
}

/* Обновить datalist у всех строк фильтров */

function refreshAllFilterDatalists(){
  const rows = document.querySelectorAll('#filtersContainer .filter-row');
  rows.forEach(row => refreshDatalistForRow(row));
}

/* Сбор фильтров из UI */

function getFiltersFromUI(){
  const rows = document.querySelectorAll('#filtersContainer .filter-row');
  const filters = [];
  rows.forEach(row => {
    const field = row.querySelector('.filter-field').value;
    const op = row.querySelector('.filter-op').value;
    const value = (row.querySelector('.filter-value').value || '').trim();
    if(field && value){
      filters.push({field, op, value});
    }
  });
  return filters;
}

/* Кнопка "Добавить фильтр" */

$('#btnAddFilter').addEventListener('click', () => {
  addFilterRow();
});

/* Проверка записи по фильтрам */

function passesAllFieldFilters(flat, filters){
  if(!filters.length) return true;
  for(const f of filters){
    if(!passesFieldFilter(flat, f.field, f.op, f.value)) return false;
  }
  return true;
}

function passesFieldFilter(flat, field, op, val){
  if(!field || !val) return true;
  const raw = flat[field];
  if(raw === undefined) return false;
  const v = Array.isArray(raw) ? raw[0] : raw;
  const s = String(v);
  const valStr = String(val);

  if(op === 'contains'){
    return s.toLowerCase().includes(valStr.toLowerCase());
  }

  const type = detectType(v);
  if(type === 'число'){
    const n = Number(String(v).replace(',', '.'));
    const nVal = Number(valStr.replace(',', '.'));
    if(Number.isNaN(n) || Number.isNaN(nVal)) return false;
    if(op === 'eq') return n === nVal;
    if(op === 'ge') return n >= nVal;
    if(op === 'le') return n <= nVal;
  }else if(type === 'дата'){
    const d = Date.parse(String(v));
    const dVal = Date.parse(valStr);
    if(Number.isNaN(d) || Number.isNaN(dVal)) return false;
    if(op === 'eq') return d === dVal;
    if(op === 'ge') return d >= dVal;
    if(op === 'le') return d <= dVal;
  }else{
    if(op === 'eq') return s === valStr;
    if(op === 'ge') return s >= valStr;
    if(op === 'le') return s <= valStr;
  }
  return false;
}

function passesFullFilter(flat, full){
  if(!full) return true;
  const text = JSON.stringify(flat).toLowerCase();
  return text.includes(full);
}

/* Кнопка "Показать" */

$('#btnPreview').addEventListener('click', () => {
  if(!recordNodes.length){
    setStatus('Отчёт не загружен', 'warn');
    return;
  }

  const limitRaw = $('#previewCount').value;
  const limit = (limitRaw === 'all') ? Infinity : (Number(limitRaw) || 10);

  if(limitRaw === 'all' && recordNodes.length > 5000){
    setStatus(
      'Вы выбрали показ всех записей (' + recordNodes.length +
      '). Для браузера это может быть тяжело — возможны подвисания.',
      'warn'
    );
  }

  const full = ($('#fullTextFilter').value || '').trim().toLowerCase();
  const filters = getFiltersFromUI();

  const results = [];
  for(const node of recordNodes){
    if(results.length >= limit) break;
    const flat = flattenNode(node);
    if(!passesAllFieldFilters(flat, filters)) continue;
    if(!passesFullFilter(flat, full)) continue;
    results.push(flat);
  }

  previewCache = results;
  renderPreviewTable(results);
  const hasData = !!results.length;
  $('#btnExport').disabled = !hasData;
  $('#btnExportCsv').disabled = !hasData;

  setStatus(
    'Найдено записей (показано: ' +
    (limit === Infinity ? ('все ' + results.length) : results.length) + ')',
    'ok'
  );
});

/* Рендер таблицы предпросмотра с учётом видимости столбцов */

function renderPreviewTable(arr){
  const box = $('#previewBox');
  box.innerHTML = '';
  if(!arr.length){
    box.innerHTML = '<div class="rowline small">Нет записей, удовлетворяющих фильтру</div>';
    return;
  }

  const keySet = new Set();
  arr.forEach(o => Object.keys(o).forEach(k => keySet.add(k)));
  let keys = Array.from(keySet);

  // применяем настройки видимости столбцов
  keys = keys.filter(k => columnVisibility.get(k) !== false);
  if(!keys.length){
    box.innerHTML = '<div class="rowline small">Все столбцы скрыты. Отметьте хотя бы один столбец в списке справа.</div>';
    return;
  }
  lastPreviewColumns = keys.slice();

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  keys.forEach(k => {
    const th = document.createElement('th');
    th.textContent = displayFieldName(k);
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  arr.forEach(o => {
    const tr = document.createElement('tr');
    keys.forEach(k => {
      const td = document.createElement('td');
      const v = o[k];
      td.textContent = typeof v === 'object' ? JSON.stringify(v) : (v ?? '');
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  box.appendChild(table);
}

/* Экспорт JSON */

$('#btnExport').addEventListener('click', () => {
  if(!previewCache.length) return;
  const blob = new Blob([JSON.stringify(previewCache, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'report-sample.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(a.href);
});

/* Экспорт CSV (по видимым столбцам) */

$('#btnExportCsv').addEventListener('click', () => {
  if(!previewCache.length) return;

  const cols = lastPreviewColumns.length
    ? lastPreviewColumns.slice()
    : Object.keys(previewCache[0] || {});

  if(!cols.length){
    setStatus('Нет столбцов для экспорта CSV', 'warn');
    return;
  }

  function toCsvCell(v){
    const s = v == null ? '' : String(v);
    const escaped = s.replace(/"/g, '""');
    return `"${escaped}"`;
  }

  const lines = [];
  // заголовок
  lines.push(cols.map(c => toCsvCell(displayFieldName(c))).join(';'));

  // строки
  previewCache.forEach(row => {
    const vals = cols.map(c => {
      const v = row[c];
      return toCsvCell(typeof v === 'object' ? JSON.stringify(v) : (v ?? ''));
    });
    lines.push(vals.join(';'));
  });

  const blob = new Blob([lines.join('\r\n')], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'report-sample.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(a.href);
});

/* Сброс фильтров */

$('#btnClearFilters').addEventListener('click', () => {
  $('#previewCount').value = '10';
  $('#fullTextFilter').value = '';
  resetFiltersUI();
  previewCache = [];
  lastPreviewColumns = [];
  renderPreviewPlaceholder();
  $('#btnExport').disabled = true;
  $('#btnExportCsv').disabled = true;
  setStatus('Фильтры сброшены', 'ok');
});

/* Сворачивание/разворачивание блоков */

document.querySelectorAll('.step-toggle').forEach(btn => {
  btn.addEventListener('click', () => {
    const targetId = btn.dataset.toggle;
    const target = document.getElementById(targetId);
    if(!target) return;
    const isHidden = target.classList.toggle('hidden-block');
    if(isHidden){
      if(btn.textContent.indexOf('Свернуть') !== -1){
        btn.textContent = btn.textContent.replace('Свернуть','Развернуть');
      }else{
        btn.textContent = 'Развернуть';
      }
    }else{
      if(btn.textContent.indexOf('Развернуть') !== -1){
        btn.textContent = btn.textContent.replace('Развернуть','Свернуть');
      }else if(!btn.textContent){
        btn.textContent = 'Свернуть';
      }
    }
  });
});

/* Инициализация */

setStatus('Готово','ok');
renderListItems();
renderMetaInfo(null);
renderMetaVersions();
clearDataState();
resetFiltersUI();
</script>
</body>
</html>
